<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shadowroot404 | Ho√†ng Ti·∫øn Minh</title>
  <style>
    /* ===== Page layout (card gi·ªØ nguy√™n b·ªë c·ª•c b·∫°n th√≠ch) ===== */
    :root {
      --card-bg: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      --muted: #9fb7d6;
      --accent: #8fe9ff;
    }

    html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; background:#02030a; color:#eaf2ff; }
    a { color:inherit; text-decoration:none; }
    canvas#star-canvas { position:fixed; inset:0; width:100%; height:100%; display:block; z-index:-1; pointer-events:none; }

    .wrap { min-height:100vh; display:flex; align-items:center; justify-content:center; padding:28px; box-sizing:border-box; }
    .card { width:100%; max-width:920px; background:var(--card-bg); border:1px solid rgba(255,255,255,0.06); backdrop-filter:blur(8px); padding:28px; border-radius:14px; box-shadow:0 10px 30px rgba(2,6,23,0.6); color:#e6eefc; text-align:left; }
    header h1 { margin:0; font-size:2.1rem; letter-spacing:.6px; color:#dffcff; }
    header p.lead { margin:8px 0 18px; color:#bcd7ff; opacity:.95; }

    .meta { margin-top:18px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .contact { display:inline-block; background:rgba(255,255,255,0.02); padding:14px 16px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); color:#dffcff; font-size:.98rem; line-height:1.6; }
    .contact a { color:var(--accent); font-weight:600; }
    .btn { display:inline-block; padding:8px 12px; border-radius:8px; background:linear-gradient(90deg,#00e676,#00b894); color:#05130b; font-weight:700; text-decoration:none; box-shadow:0 6px 18px rgba(0,200,120,0.12); }
    footer { margin-top:18px; color:var(--muted); font-size:.9rem; }

    @media (max-width:720px) { .card{padding:18px;border-radius:12px} header h1{font-size:1.6rem} .contact{font-size:.95rem} }

    /* Accessibility focus */
    a:focus { outline:3px solid rgba(143,233,255,0.26); outline-offset:3px; border-radius:6px; }

    /* noscript fallback */
    .noscript-note { background:rgba(255,255,255,0.02); padding:10px; border-radius:8px; color:#bcd7ff; margin-top:12px; }
  </style>
</head>
<body>
  <!-- Canvas n·ªÅn sao ph·ªß k√≠n m√†n h√¨nh -->
  <canvas id="star-canvas" aria-hidden="true"></canvas>

  <div class="wrap">
    <main class="card" role="main" aria-labelledby="pageTitle">
      <header>
        <h1 id="pageTitle">üåå Shadowroot404 ‚Äî Ho√†ng Ti·∫øn Minh</h1>
        <p class="lead">Website c√° nh√¢n ‚Äî ghi ch√©p v·ªÅ Linux, b·∫£o m·∫≠t v√† c√°c d·ª± √°n nh·ªè. Ch√†o b·∫°n!</p>
      </header>

      <div class="meta">
        <div class="contact" aria-label="Th√¥ng tin li√™n h·ªá">
          üìß Email: <a href="mailto:sh4d0wr00t404@gmail.com">sh4d0wr00t404@gmail.com</a><br>
          üì± Phone: <a href="tel:0899403081">0899403081</a><br>
          üåê Facebook: <a href="https://www.facebook.com/HoangTienMinh55555" target="_blank" rel="noopener noreferrer">Ho√†ng Ti·∫øn Minh</a>
        </div>

        <div style="margin-left:auto">
          <a class="btn" href="#projects" title="Xem d·ª± √°n">Xem d·ª± √°n</a>
        </div>
      </div>

      <footer>¬© <span id="year"></span> Shadowroot404. Host on GitHub Pages.</footer>

      <noscript><div class="noscript-note">JavaScript ƒëang t·∫Øt ‚Äî n·ªÅn sao ƒë·ªông v√† sao bƒÉng s·∫Ω kh√¥ng hi·ªÉn th·ªã. Vui l√≤ng b·∫≠t JS ƒë·ªÉ xem hi·ªáu ·ª©ng ƒë·∫ßy ƒë·ªß.</div></noscript>
    </main>
  </div>

  <script>
  (function () {
    'use strict';
    const canvas = document.getElementById('star-canvas');
    const ctx = canvas.getContext('2d', { alpha: true });

    // ====== C·∫§U H√åNH: ch·ªânh ·ªü ƒë√¢y n·∫øu c·∫ßn ======
    const CONFIG = {
      STAR_COUNT_DESKTOP: 1400,   // s·ªë sao tr√™n desktop (gi·∫£m n·∫øu lag)
      STAR_COUNT_MOBILE: 480,     // s·ªë sao tr√™n mobile
      GLOBAL_ROT_SPEED: 0.0008,   // t·ªëc ƒë·ªô quay t·ªïng (radians/sec) ‚Äî r·∫•t ch·∫≠m
      SHOOT_INTERVAL_MS: 260,     // ki·ªÉm tra spawn sao bƒÉng m·ªói X ms
      MAX_SHOOT_PER_TICK: 4,      // t·ªëi ƒëa sao bƒÉng / tick (desktop)
      TWINKLE_MIN: 0.4,
      TWINKLE_MAX: 2.6
    };

    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    let DPR = Math.max(1, window.devicePixelRatio || 1);
    let W = 0, H = 0, CX = 0, CY = 0;
    let stars = [], shooting = [];
    let lastRender = performance.now();
    let globalAngle = 0;

    // Parallax target (subtle)
    const parallax = { tx: 0, ty: 0, x: 0, y: 0 };
    let mouseTick = false;
    function onPointerMove(e) {
      if (prefersReduced) return;
      const clientX = e.clientX ?? (e.touches && e.touches[0] && e.touches[0].clientX) ?? CX;
      const clientY = e.clientY ?? (e.touches && e.touches[0] && e.touches[0].clientY) ?? CY;
      parallax.tx = (clientX / W - 0.5) * 36;
      parallax.ty = (clientY / H - 0.5) * 18;
      if (!mouseTick) {
        mouseTick = true;
        requestAnimationFrame(() => { mouseTick = false; });
      }
    }
    window.addEventListener('mousemove', onPointerMove, { passive: true });
    window.addEventListener('touchmove', onPointerMove, { passive: true });

    function rand(min, max) { return Math.random() * (max - min) + min; }

    function resize() {
      DPR = Math.max(1, window.devicePixelRatio || 1);
      W = window.innerWidth;
      H = window.innerHeight;
      CX = W / 2;
      CY = H / 2;
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      canvas.width = Math.round(W * DPR);
      canvas.height = Math.round(H * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      initStars();
    }

    function initStars() {
      const target = prefersReduced ? Math.round((isMobile ? CONFIG.STAR_COUNT_MOBILE : CONFIG.STAR_COUNT_DESKTOP) * 0.45)
                                    : (isMobile ? CONFIG.STAR_COUNT_MOBILE : CONFIG.STAR_COUNT_DESKTOP);
      stars = new Array(target).fill(null).map(() => {
        const maxR = Math.hypot(CX, CY);
        const r = Math.sqrt(Math.random()) * maxR; // bias toward center
        return {
          r,
          theta: rand(0, Math.PI * 2),
          size: rand(0.28, 2.6),
          baseAlpha: rand(0.08, 0.95),
          twinkleSpeed: rand(CONFIG.TWINKLE_MIN, CONFIG.TWINKLE_MAX),
          twinklePhase: Math.random() * Math.PI * 2,
          twinkleRange: rand(0.12, 0.85),
          speedMul: rand(0.88, 1.18),
          hueShift: rand(-18, 18),
          freeze: Math.random() < 0.012
        };
      });
    }

    function spawnShootingStar() {
      const len = rand(120, 420);
      const speed = rand(900, 1700);
      const startX = rand(W * 0.45, W * 1.05);
      const startY = rand(-120, H * 0.32);
      shooting.push({
        x: startX,
        y: startY,
        vx: -speed * (Math.random() * 0.25 + 0.88) / 60,
        vy: speed * (Math.random() * 0.25 + 0.88) / 100,
        life: 0,
        maxLife: rand(0.7, 1.6),
        len
      });
    }

    // Spawn logic: denser on desktop
    setInterval(() => {
      if (prefersReduced && Math.random() > 0.25) return;
      const isDesktop = !isMobile;
      const chance = isDesktop ? 0.92 : 0.5;
      if (Math.random() < chance) {
        const maxPer = isDesktop ? CONFIG.MAX_SHOOT_PER_TICK : 1;
        const count = Math.floor(Math.random() * maxPer) + 1;
        for (let i = 0; i < count; i++) {
          setTimeout(spawnShootingStar, Math.random() * 300);
        }
      }
    }, CONFIG.SHOOT_INTERVAL_MS);

    // draw loop
    function draw(now) {
      const dt = Math.min(0.05, (now - lastRender) / 1000);
      lastRender = now;

      if (!prefersReduced) globalAngle += CONFIG.GLOBAL_ROT_SPEED * dt * 1000; // scaled for visible but slow rotation

      // smooth parallax
      parallax.x += (parallax.tx - parallax.x) * Math.min(0.12, dt * 8);
      parallax.y += (parallax.ty - parallax.y) * Math.min(0.12, dt * 8);

      ctx.clearRect(0, 0, W, H);

      // subtle gradient background
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, 'rgba(6,10,20,0.06)');
      g.addColorStop(0.6, 'rgba(3,5,10,0.25)');
      g.addColorStop(1, 'rgba(2,3,6,0.65)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);

      // draw stars
      for (let i = 0; i < stars.length; i++) {
        const s = stars[i];
        const angle = s.theta + globalAngle * s.speedMul;
        const x = CX + s.r * Math.cos(angle) + parallax.x * (s.r / Math.max(W, H)) * 12;
        const y = CY + s.r * Math.sin(angle) + parallax.y * (s.r / Math.max(W, H)) * 6;

        const t = now * 0.001 * s.twinkleSpeed + s.twinklePhase;
        let alpha = s.freeze ? s.baseAlpha : (s.baseAlpha + Math.sin(t) * s.twinkleRange * 0.6);
        alpha = Math.max(0, Math.min(1, alpha));

        const grad = ctx.createRadialGradient(x, y, 0, x, y, 8 * s.size);
        grad.addColorStop(0, `rgba(${Math.floor(240 + s.hueShift)},${Math.floor(245 + s.hueShift)},255,${alpha})`);
        grad.addColorStop(0.45, `rgba(220,230,255,${alpha * 0.6})`);
        grad.addColorStop(1, `rgba(200,210,230,${alpha * 0.02})`);
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, s.size * 3.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = `rgba(255,255,255,${Math.min(1, alpha * 1.2)})`;
        ctx.beginPath();
        ctx.arc(x, y, Math.max(0.2, s.size * 0.65), 0, Math.PI * 2);
        ctx.fill();
      }

      // draw shooting stars
      for (let i = shooting.length - 1; i >= 0; i--) {
        const st = shooting[i];
        st.life += dt;
        const progress = st.life / st.maxLife;

        st.x += st.vx * dt * 60;
        st.y += st.vy * dt * 60;

        ctx.save();
        const grad = ctx.createLinearGradient(st.x, st.y, st.x - st.vx * 0.5, st.y - st.vy * 0.5);
        const falloff = Math.max(0, 1 - progress);
        grad.addColorStop(0, `rgba(255,255,255,${0.98 * falloff})`);
        grad.addColorStop(0.6, `rgba(200,230,255,${0.28 * falloff})`);
        grad.addColorStop(1, `rgba(200,230,255,0)`);
        ctx.strokeStyle = grad;
        ctx.lineWidth = Math.max(1, st.len / 60);
        ctx.beginPath();
        ctx.moveTo(st.x, st.y);
        ctx.lineTo(st.x - st.vx * st.len * 0.03, st.y - st.vy * st.len * 0.03);
        ctx.stroke();

        ctx.fillStyle = `rgba(255,255,255,${0.9 * falloff})`;
        ctx.beginPath();
        ctx.arc(st.x - st.vx * 0.015, st.y - st.vy * 0.015, Math.max(1.2, st.len / 140), 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        if (st.life > st.maxLife) shooting.splice(i, 1);
      }

      requestAnimationFrame(draw);
    }

    // startup
    function start() {
      resize();
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(resize, 160);
      }, { passive: true });

      // shooting interval handled already via setInterval spawn logic below
      requestAnimationFrame(draw);
    }

    let resizeTimer = null;
    function resize() {
      DPR = Math.max(1, window.devicePixelRatio || 1);
      W = window.innerWidth;
      H = window.innerHeight;
      CX = W / 2;
      CY = H / 2;
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      canvas.width = Math.round(W * DPR);
      canvas.height = Math.round(H * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      initStars();
    }

    function initStars() {
      const target = prefersReduced ? Math.round((isMobile ? CONFIG.STAR_COUNT_MOBILE : CONFIG.STAR_COUNT_DESKTOP) * 0.45)
                                    : (isMobile ? CONFIG.STAR_COUNT_MOBILE : CONFIG.STAR_COUNT_DESKTOP);
      stars = new Array(target).fill(null).map(() => {
        const maxR = Math.hypot(CX, CY);
        const r = Math.sqrt(Math.random()) * maxR;
        return {
          r,
          theta: rand(0, Math.PI * 2),
          size: rand(0.28, 2.6),
          baseAlpha: rand(0.08, 0.95),
          twinkleSpeed: rand(CONFIG.TWINKLE_MIN, CONFIG.TWINKLE_MAX),
          twinklePhase: Math.random() * Math.PI * 2,
          twinkleRange: rand(0.12, 0.85),
          speedMul: rand(0.88, 1.18),
          hueShift: rand(-18, 18),
          freeze: Math.random() < 0.012
        };
      });
    }

    // spawn a few initial shooting stars
    function initialShots() {
      if (!prefersReduced) {
        spawnShootingStar();
        setTimeout(spawnShootingStar, 700);
      }
    }

    // periodic shooter ticks
    setInterval(() => {
      if (prefersReduced && Math.random() > 0.25) return;
      const maxPer = isMobile ? 1 : CONFIG.MAX_SHOOT_PER_TICK;
      const toSpawn = Math.floor(Math.random() * maxPer) + 1;
      for (let i = 0; i < toSpawn; i++) setTimeout(spawnShootingStar, Math.random() * 360);
    }, CONFIG.SHOOT_INTERVAL_MS);

    // start everything
    resize();
    initialShots();
    start();

    // expose CONFIG for console tweak if needed
    window.__STAR_CFG = CONFIG;

    // footer year
    document.getElementById('year').textContent = new Date().getFullYear();

  })();
  </script>
</body>
</html>
